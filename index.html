<!DOCTYPE html>
<html lang="en">
<head>
    <title>Home</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="subject" content='This is the homepage'>
    <meta name="description" content="This is the homepage" />
    <meta name="keywords" content="none"/>
    <meta name="author" content="Don Le, ledongduu@gmail.com"/>
    <meta name="format-detection" content="telephone=no"> <!-- Disable number string recognition-->
    <link rel="stylesheet" href="/neumanncondition/assets/css/main.css">
    <link rel="stylesheet" href="/neumanncondition/assets/css/canvas-banner.css">
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
    <script src="/neumanncondition/assets/js/mathjax-setting.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript" id="MathJax-script" async></script>
    <style>
        #Home-button{
            font-weight: var(--top-buttons-font-weight);
            color:var(--top-buttons-hover-color);
        }
    </style>
</head>

<body class="nav-open light-mode">
    <div class = "top-nav"></div>
    <nav class="navbar open" id="navbar">
        <div id="logo"></div>
        <div class = "side-nav-container"></div>
        <div class = "highlights-and-attribute"></div>
    </nav>

    <div class="content-grid" id="content-grid">
        <div class="home-banner" id="home-banner"></div><script src="/neumanncondition/assets/js/canvas-banner.js"></script>
        <div class = "general-wrapper" id="home">
            <div class = "topic">
                Homepage
            </div>
            
            
            <h1 class="home-title">When does time complexity start to matter?</h1>
            <div class = "two-columns-block">
                <div>
                    <p>
                        If you have taken data structure, you must have already learned about the three methods of determining the runtime of an algorithm: the Big-O (upper bound), the Big-$\Omega$ (lower bound), and the Big-$\Theta$ (exact bound). They simply tell us how the runtime would increase as the number of input to an algorithm, $n$ increases.
                    </p>
                    <p>
                        With the speed of the modern computers, it is not quite obvious to notice the slight change in runtime between different time complexities, especially when running only a small code segment. To truly know when it actually matters, we must run the code segment for tens of thousands of random value and plot our runtime. Depending on the algorithm, we will see some clear and fascinating pattern as shown in Figure 1.
                    </p>
                    <div style="text-align: center;">
                        <div class="redirect-button"><a href="#">Read More</a></div>
                    </div>
                </div>
                <div>
                    <img style="width: 75%;" class="image"  src = "/neumanncondition/public/Images/O_n_filter.png">
                    <figcaption class="caption"> Linear runtime illustration.</figcaption>
                </div>
            </div>


            <h1 class="home-title">Euler vs. High Order Taylor vs. RK 4</h1>
            <p>
                <!-- The computer enables us to do almost anything in the modern world, such as weather modeling, but everything a computer does boils down to its ability to execute computation, which it does considerably faster than a human. The RK4 algorithm for approximating initial value problems is a prime example of how powerful computers can be. If we set the number of iterations to one billion, it would take a person hundreds of years of non-stop calculations to finish, but today's computers can easily reduce that number to less than 10 seconds. -->
                The language of modeling problems in science and engineering is in the form of differential equations. In some special case, a differential equation might have an elementary solution, which can be solved using the techniques we learn in a standard DE class. Most of the time, however, they are unsolvable, and meaningful results can only be achieved via approximations. Euler, Taylor, and Runge Kutta are all common methods used to approximate such initial value problems, commonly expressed as
                <div class="equation">
                    $$y'(t) = f(t, y),\quad a\leq t\leq b,\quad y(a) = \alpha,$$
                </div>
                If $w_0, w_1, \ldots, w_n$ are approximations generated by Euler's method, then, for each $i = 0, 1, 2, \ldots, n$, the error bound of Euler's method is determined by
                <div class="equation">
                    $$E=|y(t_i) - w_i| \leq \frac{hM}{2L}[e^{L(t_i - a)} - 1] \sim O\left(e^{L(t_i - a)}\right)$$
                </div>
                On the other hand, since the RK4 method is determined by
                $w_{i+1} = w_i + \frac{1}{6}(K_1 + 2K_2 + 2K_3 + K_4) + O(h^5),$
                its truncation error must be
                $$E = |y(t_i) - w_i| = Ch^5 \sim O(h^5)$$
                Last, but not least, if $y\in C^{n+1}[a,b]$ and has a step size $h$, then the local truncation error the $n$-order Taylor method is $O(h^n)$.
            </p>

            <h1 class="home-title">Articles</h1>
            <div id="rec-article-container" data-aos="fade-up"></div>
        </div>
    </div>
    
    <div class="footer"></div>
    <script src="/neumanncondition/assets/js/scripts.js"></script>
    <script src="/neumanncondition/assets/js/load.js"></script>
    <script src="/neumanncondition/assets/js/homepage-setting.js"></script>
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    <script>
        AOS.init({
            easing: 'ease-in-quad',
            once: false, // whether animation should happen only once - while scrolling down
        });
    </script>
</body>
</html>