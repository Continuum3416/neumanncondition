<!DOCTYPE html>
<html lang="en">
<head>
    <title>The Big O Notation</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="subject" content='here'>
    <meta name="description" content="here" />
    <meta name="keywords" content="data structures, algorithms, c++, cpp, computer science" />
    <meta name="author" content="Don Le, ledongduu@gmail.com"/>
    <meta name="format-detection" content="telephone=no"> <!-- Disable number string recognition-->
    <link rel="stylesheet" href="../../assets/css/main.css">
    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
    <style>
        .front-img{
            display: block;
            width: 100%;
            border-radius: 10px;
            height: auto; 
            margin: auto;
        }
    </style>
</head>

<body class="nav-open light-mode">
    \[
        \newcommand{\lbrac}{\left(}
        \newcommand{\rbrac}{\right)}
    \]        
    <div class = "top-nav"></div> <!-- TOP NAV-->   
    <nav class="navbar open" id="navbar"> <!-- SIDE BAR -->
        <div id="logo"></div>
        <div class = "side-nav-container"></div> <!--open attribute - default-->
        <div class="line-3"></div>
        <header class="major"><h2>Table of Contents</h2></header>   <!-- TABLE OF CONTENTS -->
        <div class = "toc">
            <ul>
                <li>Introduction</li>
                <li><a href="#Appendix">Appendix</a></li>
                <li><a href="#References">References</a></li>
            </ul>
        </div>
        <div class = "highlights-and-attribute"></div>
    </nav>

    <!--Master grid starts here -->
    <div class="content-grid">
        
        <!-- CONTENTS -->
        <div class = "general-wrapper">
            
            
            <header>
                <div class = "topic">
                    Topics: Computer-Science/Data-Structure/Algorithms/C++
                </div>
                <h1 class = "title">Time Complexity of an Algorithm</h1>
                <div class="date"></div>
                <figure style="margin: 0;">
                    <img class = "front-img" src = "time-complexity-banner.png" alt = "image">
                </figure>
                <div class="Quote">
                    <div class="Quote-content">&#8220Science is what we understand well enough to explain to a computer. Art is everything else we do.&#8221</div>
                    <div class="Author">- Donald Knuth</div>
                </div>
            </header>
           
        
            
            
            <section>
                <h2 id= "Introduction">What is the Best Way to Compare Algorithms' Efficiency?</h2>

                <p>
                    Given two algorithms that perform the same task, what is the best way to compare their performance? At first glance, one might consider measuring the runtime of the two algorithms. However, this is not a reliable metric, as runtime depends heavily on the hardware and can be highly inconsistent due to real-world conditions, even on the same machine. To address this problem, scientists have developed a more theoretical approach called the time complexity of an algorithm. This measure evaluates how an algorithm's performance scales as the size of the input increases.
                </p>
                <p>
                    If $n$ is the number of input, then for a given algorithm, there exists a function $f(n)$ that measures the worst-case runtime of the algorithm as $n$ varies. The runtime of an algorithm generally follows a specific trend, such as constant, logarithmic, or linear. However, as noted, the runtime is significantly influenced by hardware and physical conditions. Therefore, these functions are often expressed with additional constant factors, such as: 
                </p>
                <div class="equation">
                    $$f(n) = C_1n + C_0,$$
                </div>
                <p>
                    where $C_1$ and $C_0$ are factors that depends on outside conditions. This expression is quite inconvenient, as we don't usually know what these constant factors are, so the general rule of thumb to express the worst-case runtime of an algorithm is through the big-O notation. For $f(n) = C_1n + C_0$, for example, can be rewritten as
                </p>
                <div class="equation">
                    $$f(n) = C_1n + C_0\sim O(n).$$
                </div>
                <p>
                    There are many categories of such functions $f(n)$, and the most important functions used in algorithmic analysis are the constant function, $f(n)=c$, the logarithm function $f(n) = \log_b(n)$, the linear function $f(n) = n$, $f(n) = n\log(n)$, the quadratic function $f(n) = n^2$, other polynomial functions $f(n) = n^d$, the exponential functions $f(n) = a^n$, and the factorial function $f(n) = n!$.
                </p>

                <section>
                    <h3>The constant function</h3>
                    <p>
                        The constant time complexity function, denoted
                    </p>
                    <div class="equation">
                        $$f(n) = c \;\sim\; O(1),$$
                    </div>
                    <p>
                        does not depend on the size of the input (unless the size of the input is exceptionally large). Some examples of algorithms with this complexity are:
                    </p>
                    <ul style="line-height: 1.6;">
                        <li style="margin: var(--in-page-li-spacing) 0;">Accessing array index: Accessing elements at a specific index in an array takes constant time because an array begins at a fixed memory location. The memory location of each element can be directly calculated using the element's size and its index, which is a constant operation.
                            
                        </li>
                        <li style="margin: var(--in-page-li-spacing) 0;">
                        <p>
                            Basic arithmetic and bitwise operations: Computers usually uses 8-bit, 16-bit, 32-bit, and 64-bit for integers and floating point numbers. Addition, subtraction, multiplication, or division of two numbers are considered constant time complexity because they are limited to a certain amount of bit. However, for large number arithmetic with arbitrary precision, the time complexity will no longer be constant.
                        </p>
                        <p>
                            Bitwise operations like AND, OR, and XOR also take constant time because, again, primitive data types are limited to a certain size on the computer.
                        </p>
                        </li>
                        <li style="margin: var(--in-page-li-spacing) 0;">Variable assignment: For primitive data types such as integers, floating points, characters, and boolean, the assignment operator takes constant time complexity because the size of these variables are pre-determined. However, for non-primitive data types such as strings, the assignment operator takes linear time, $O(n)$ because strings are arrays of characters.

                        </li>
                        <li style="margin: var(--in-page-li-spacing) 0;">Returning a value from a function: Returning a pre-defined value also takes constant time.

                        </li>
                        <li style="margin: var(--in-page-li-spacing) 0;">
                            Inserting a node, or jump to the next/previous node in a linked list: These operation are constant because each node holds the address of the next node (for a singly linked list), or the address of both the previous and the next node (for a doubly linked list).
                        </li>
                        <li style="margin: var(--in-page-li-spacing) 0;">
                            Pushing and popping on stack. Insertion and removal from queue.
                        </li>
                        <li style="margin: var(--in-page-li-spacing) 0;">Hashmap operations: Insert, access, and search operations in a hash map take constant time on average (ideally). These operations are $O(1)$ on average because a hash map uses a bucket array, and accessing elements in an array is $O(1)$. The hash function computes an index for a given key, and ideally, keys are distributed evenly across the buckets. However, if all keys end up in the same bucket due to hash collisions (e.g., in separate chaining), these operations degrade to $O(n)$ in the worst case, where $n$ is the total number of keys in the hash map.

                        </li>
                    </ol>
                </section>


                <section>
                    <h3>The Logarithm Function</h3>
                    <p>
                        Some examples of this type of algorithms are:
                    </p>
                    <ul style="line-height: 1.6;">
                        <li style="margin: var(--in-page-li-spacing) 0;">Binary search: binary search involves searching for an element in a sorted array. This algorithm is $O(\log n)$ because it utilizes the divide and conquer technique, where the size of the array reduces by half every iteration.
                            
                        </li>
                        <li style="margin: var(--in-page-li-spacing) 0;">Calculate the 64-bit (or below) $n$-th Fibinacci number with <a href="https://www.geeksforgeeks.org/fast-doubling-method-to-find-the-nth-fibonacci-number/" class="url">fast doubling method</a>.
                            
                        </li>
                        <li style="margin: var(--in-page-li-spacing) 0;">Balanced Binary Search Trees (e.g., AVL Tree, Red-Black Tree)
                            
                        </li>
                    </ul>
                </section>



                <section>
                    <h3>The Linear Function</h3>
                </section>


                <section>
                    <h3>The $n\log n$ Function</h3>
                </section>


                <section>
                    <h3>The Exponential Function</h3>
                    <ul style="line-height: 1.6;">
                        <li style="margin: var(--in-page-li-spacing) 0;">Find all sub-array of an array. This algorithm has an exponential time complexity because the total number of sub-arrays in an array of size $n$ is
                        <div class="equation">
                            $$S = \sum_{k=1}^{n}\binom{n}{k} = 2^n - 1.$$
                        </div>
                        </li>
                    </ul>
                </section>
            </section>


            <section>
                <h2>When Does Time Complexity Start to Matter?</h2>

                <p>
                    With the speed of the modern computers, it is not quite obvious to notice the slight change in runtime between different time complexities, especially when running only a small code segment. To truly know when it actually matters, we can do something like this: run the code segment for tens of thousands of random value and plot our runtime. Let's write a simple program to verify this.
                </p>
<div class="box" style="margin: 30px 0;">
    <div class="tab-button-container">
        <button class="tab-button tab-effect" onclick="changeTab(event, 'main-cpp', 'pseudo-tab')">main.cpp</button>
        <button class="tab-button" onclick="changeTab(event, 'maximum_summation-h', 'pseudo-tab')">maximum_summation.h</button>
        <button class="tab-button" onclick="changeTab(event, 'time_measure-py', 'pseudo-tab')">time_measurement.py</button>
    </div>
<div class="code-container pseudo-tab" id="main-cpp">
    <button class="copy-btn" style="position: absolute">Copy</button>
<pre style="border-radius: 0px 7px 7px 7px;" class="line-numbers"><code class="language-cpp"><script type="prism-cpp">// program to find a maximum contiguous sub-array.
#include <iostream>
#include <vector>
#include <chrono>
#include <ctime>
#include <cstdlib>
#include <iomanip>
#include <fstream> 
#include <string> 
#include "maximum_summation.h"

using namespace std;
using namespace std::chrono;

int main(){
    vector <int> A;
    int upper_bound = 10000;
    int lower_bound = -10000;

    for(int j = 0; j < 3; j++){
        string fileName = "python/timing_data" + to_string(j + 1)+".txt";
        ofstream file(fileName);

        cout << left << setw(10) << "n" << setw(15) << "time (milliseconds)" << endl;
        cout << string(25, '-') << endl;

        file << "n,time_ms" << endl;
        for(int n = 1; n <= 500; n += 1) {
            srand(time(0) + n);
            A.reserve(n); 

            for (int i = 0; i < n; ++i) {
                int random_int = (rand()%(upper_bound - lower_bound)) + lower_bound;
                A.push_back(random_int);
            }

            auto start = high_resolution_clock::now();
            f[j](A);
            auto end = high_resolution_clock::now();

            auto duration_ms = duration_cast<duration<double, milli>>(end - start);

            cout << left << setw(10) << n << setw(20) << fixed << setprecision(6) << duration_ms.count() << endl;
            file << n << "," << fixed << setprecision(3) << duration_ms.count() << endl;

            A.clear();
            
        }
    }

    // Run: g++ main.cpp -o main.exe; ./main.exe
    return 0;
}
</script></code></pre>
</div>




<div class="code-container pseudo-tab" id="maximum_summation-h" style="display: none">
    <button class="copy-btn" style="position: absolute">Copy</button>
<pre style="border-radius: 0px 7px 7px 7px;" class="line-numbers"><code class="language-cpp"><script type="prism-cpp">#pragma once

typedef int (*Function_Vector) (const std::vector<int>& A);

// output the largest sum found in a sub-array
// there should be sum_{i = 0}^{size} binom(size, i) = 2^n sub-arrays
// and there should be 1 + 2 + ... + n = n(n + 1)/2 consecutive sub-arrays
int maximumSummation1(const std::vector<int>& A) {
    if (A.size() == 0) return 0;

    int maxSoFar = A[0];
    int maxEndingHere = A[0];

    for (int i = 1; i < A.size(); i++) {
        maxEndingHere = std::max(A[i], maxEndingHere + A[i]);   // O(1)
        maxSoFar = std::max(maxSoFar, maxEndingHere);           // O(1)
    }

    return maxSoFar;
}

int maximumSummation2(const std::vector<int>& A){
    if (A.size() == 0) return 0;

    int max = A[0];
    for(int i = 0; i < A.size(); i++){
        int sum = 0;
        for(int j = i; j < A.size(); j++){
            sum += A[j];
            if(sum > max)
                max = sum;
        }
    }
    return max;
}   

int maximumSummation3(const std::vector<int>& A){
    if (A.size() == 0) return 0;

    int max = A[0];
    for(int i = 0; i < A.size(); i++){
        for(int j = i; j < A.size(); j++){
            int sum = 0;
            for(int k = i; k <= j; k++){
                sum += A[k];
            }
            if(sum > max)
                max = sum;
        }
    }
    return max;
}

Function_Vector f[] = {maximumSummation1, maximumSummation2, maximumSummation3};
    
</script></code></pre>
</div>


<div class="code-container pseudo-tab" id="time_measure-py" style="display: none">
    <button class="copy-btn" style="position: absolute">Copy</button>
<pre style="border-radius: 0px 7px 7px 7px;" class="line-numbers"><code class="language-python">import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import font_manager as fm

# Load the font for the plot
font_path = 'fonts/computer-modern/cmunrm.ttf'
prop = fm.FontProperties(fname=font_path)
plt.rcParams['font.family'] = prop.get_name()

# Load the data from the files
file_names = ['python/timing_data1.txt', 'python/timing_data2.txt', 'python/timing_data3.txt']
data_frames = [pd.read_csv(file) for file in file_names]

# Prepare a list of colors for each dataset
colors = ['red', 'green', 'blue']

# Plot the cleaned data for each file
plt.figure(figsize=(6, 6))
plt.grid(True, linestyle='--')
font_size = 14

for i, data in enumerate(data_frames):
    # Calculate IQR for the current dataset
    Q1 = data[['n', 'time_ms']].quantile(0.25)
    Q3 = data[['n', 'time_ms']].quantile(0.75)
    IQR = Q3 - Q1
    
    # Define outlier thresholds
    outlier_factor = 1.0
    lower_bound = (Q1 - outlier_factor * IQR).to_dict()
    upper_bound = (Q3 + outlier_factor * IQR).to_dict()
    
    # Filter out outliers
    data_clean = data[~((data[['n', 'time_ms']] < lower_bound) | (data[['n', 'time_ms']] > upper_bound)).any(axis=1)]
    
    # Sort data_clean by 'n' to connect the points in order
    data_clean = data_clean.sort_values('n')
    
    # Fit a linear model
    coefficients = np.polyfit(data_clean['n'], data_clean['time_ms'], i + 1)
    linear_fit = np.poly1d(coefficients)
    
    # Plot data points and linear fit
    plt.plot(data_clean['n'], data_clean['time_ms'], marker='o', linestyle='None', 
             color=colors[i], markersize=3, label=f'maximumSummation{i+1}')
    # plt.plot(data_clean['n'], linear_fit(data_clean['n']), color=colors[i], linestyle='-', label=f'maximumSummation{i+1}')

# Set plot labels and title
plt.xlabel('n (Number of Elements)', fontsize=font_size)
plt.ylabel('Time (milliseconds)', fontsize=font_size)
plt.title('n vs Time (milliseconds)', fontsize=font_size)
plt.legend()

plt.show()
</code></pre>
</div>


</div>
            </section>







    <div class="line-1"></div>
    <header>
        <h3>More Articles</h3>
    </header>
    <div id="rec-article-container"></div>
            

        </div> <!--general wrapper ends here-->
    </div>
    <!--Master grid ends here -->

<div class="footer"></div>
<script src="../../assets/js/scripts.js"></script>
<script src="../../assets/js/load.js"></script>
<script src="../../assets/js/blogpage-setting.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script> <!-- use prism-c.min.js or prism-clike.min.js-->

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript" id="MathJax-script" async></script>
</body>
</html>